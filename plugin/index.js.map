{
  "version": 3,
  "sources": ["src/commonObjects.ts", "src/commonFunctions.ts", "src/asserts.ts", "src/buildWorkletString.ts", "src/makeWorklet.ts", "src/processWorkletObjectMethod.ts", "src/processIfWorkletFunction.ts", "src/processForCalleesWorklets.ts", "src/processIfWorkletNode.ts", "src/processIfGestureHandlerEventCallbackFunctionNode.ts", "src/processInlineStylesWarning.ts", "src/plugin.ts"],
  "sourcesContent": ["/**\n * holds a map of function names as keys and array of argument indexes as values which should be automatically workletized(they have to be functions)(starting from 0)\n */\nconst functionArgsToWorkletize = new Map([\n  ['useFrameCallback', [0]],\n  ['useAnimatedStyle', [0]],\n  ['useAnimatedProps', [0]],\n  ['createAnimatedPropAdapter', [0]],\n  ['useDerivedValue', [0]],\n  ['useAnimatedScrollHandler', [0]],\n  ['useAnimatedReaction', [0, 1]],\n  ['useWorkletCallback', [0]],\n  // animations' callbacks\n  ['withTiming', [2]],\n  ['withSpring', [2]],\n  ['withDecay', [1]],\n  ['withRepeat', [3]],\n]);\n\nconst objectHooks = new Set([\n  'useAnimatedGestureHandler',\n  'useAnimatedScrollHandler',\n]);\n\nconst globals = new Set([\n  'this',\n  'console',\n  'performance',\n  'Date',\n  'Array',\n  'ArrayBuffer',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'HermesInternal',\n  'JSON',\n  'Math',\n  'Number',\n  'Object',\n  'String',\n  'Symbol',\n  'undefined',\n  'null',\n  'UIManager',\n  'requestAnimationFrame',\n  'setImmediate',\n  '_WORKLET',\n  'arguments',\n  'Boolean',\n  'parseInt',\n  'parseFloat',\n  'Map',\n  'WeakMap',\n  'WeakRef',\n  'Set',\n  '_log',\n  '_scheduleOnJS',\n  '_makeShareableClone',\n  '_updateDataSynchronously',\n  'eval',\n  '_updatePropsPaper',\n  '_updatePropsFabric',\n  '_removeShadowNodeFromRegistry',\n  'RegExp',\n  'Error',\n  'ErrorUtils',\n  'global',\n  '_measure',\n  '_scrollTo',\n  '_dispatchCommand',\n  '_setGestureState',\n  '_getCurrentTime',\n  'isNaN',\n  'LayoutAnimationRepository',\n  '_notifyAboutProgress',\n  '_notifyAboutEnd',\n]);\n\nconst gestureHandlerGestureObjects = new Set([\n  // from https://github.com/software-mansion/react-native-gesture-handler/blob/new-api/src/handlers/gestures/gestureObjects.ts\n  'Tap',\n  'Pan',\n  'Pinch',\n  'Rotation',\n  'Fling',\n  'LongPress',\n  'ForceTouch',\n  'Native',\n  'Manual',\n  'Race',\n  'Simultaneous',\n  'Exclusive',\n]);\n\nconst gestureHandlerBuilderMethods = new Set([\n  'onBegin',\n  'onStart',\n  'onEnd',\n  'onFinalize',\n  'onUpdate',\n  'onChange',\n  'onTouchesDown',\n  'onTouchesMove',\n  'onTouchesUp',\n  'onTouchesCancelled',\n]);\n\nexport {\n  functionArgsToWorkletize,\n  objectHooks,\n  globals,\n  gestureHandlerGestureObjects,\n  gestureHandlerBuilderMethods,\n};\n", "function hash(str: string): number {\n  let i = str.length;\n  let hash1 = 5381;\n  let hash2 = 52711;\n\n  while (i--) {\n    const char = str.charCodeAt(i);\n    hash1 = (hash1 * 33) ^ char;\n    hash2 = (hash2 * 33) ^ char;\n  }\n\n  return (hash1 >>> 0) * 4096 + (hash2 >>> 0);\n}\nfunction isRelease() {\n  return (\n    process.env.BABEL_ENV &&\n    ['production', 'release'].includes(process.env.BABEL_ENV)\n  );\n}\n\nfunction shouldGenerateSourceMap(): boolean {\n  if (isRelease()) {\n    return false;\n  }\n\n  if (process.env.REANIMATED_PLUGIN_TESTS === 'jest') {\n    // We want to detect this, so we can disable source maps (because they break\n    // snapshot tests with jest).\n    return false;\n  }\n\n  return true;\n}\nexport { hash, isRelease, shouldGenerateSourceMap };\n", "export function assertIsDefined<T>(value: T): asserts value is NonNullable<T> {\n  if (value === undefined || value === null) {\n    throw new Error(`${value} is not defined`);\n  }\n}\n", "import {\n  BabelFileResult,\n  NodePath,\n  transformSync,\n  PluginItem,\n} from '@babel/core';\nimport generate from '@babel/generator';\nimport {\n  ObjectMethod,\n  isObjectMethod,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  identifier,\n  Identifier,\n  objectProperty,\n  isArrowFunctionExpression,\n  variableDeclaration,\n  variableDeclarator,\n  isBlockStatement,\n  functionExpression,\n  isFunctionDeclaration,\n  VariableDeclaration,\n  ExpressionStatement,\n  isProgram,\n  memberExpression,\n  File as BabelFile,\n  objectPattern,\n  thisExpression,\n  isExpression,\n  isExpressionStatement,\n} from '@babel/types';\nimport * as fs from 'fs';\nimport * as convertSourceMap from 'convert-source-map';\nimport { shouldGenerateSourceMap } from './commonFunctions';\nimport { assertIsDefined } from './asserts';\n\nfunction prependClosure(\n  closureVariables: Array<Identifier>,\n  closureDeclaration: VariableDeclaration,\n  path: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ArrowFunctionExpression\n    | ObjectMethod\n  >\n): void {\n  if (closureVariables.length === 0 || !isProgram(path.parent)) {\n    return;\n  }\n\n  if (!isExpression(path.node.body))\n    path.node.body.body.unshift(closureDeclaration);\n}\n\nfunction prependRecursiveDeclaration(\n  path: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ArrowFunctionExpression\n    | ObjectMethod\n  >\n): void {\n  if (\n    isProgram(path.parent) &&\n    !isArrowFunctionExpression(path.node) &&\n    !isObjectMethod(path.node) &&\n    path.node.id &&\n    path.scope.parent\n  ) {\n    const hasRecursiveCalls =\n      path.scope.parent.bindings[path.node.id.name]?.references > 0;\n    if (hasRecursiveCalls) {\n      path.node.body.body.unshift(\n        variableDeclaration('const', [\n          variableDeclarator(\n            identifier(path.node.id.name),\n            memberExpression(thisExpression(), identifier('_recur'))\n          ),\n        ])\n      );\n    }\n  }\n}\n\nfunction prependClosureVariablesIfNecessary(\n  closureVariables: Array<Identifier>\n): PluginItem {\n  const closureDeclaration = variableDeclaration('const', [\n    variableDeclarator(\n      objectPattern(\n        closureVariables.map((variable) =>\n          objectProperty(\n            identifier(variable.name),\n            identifier(variable.name),\n            false,\n            true\n          )\n        )\n      ),\n      memberExpression(thisExpression(), identifier('_closure'))\n    ),\n  ]);\n\n  return {\n    visitor: {\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod':\n        (\n          path: NodePath<\n            | FunctionDeclaration\n            | FunctionExpression\n            | ArrowFunctionExpression\n            | ObjectMethod\n          >\n        ) => {\n          prependClosure(closureVariables, closureDeclaration, path);\n          prependRecursiveDeclaration(path);\n        },\n    },\n  };\n}\n\nfunction buildWorkletString(\n  fun: BabelFile,\n  closureVariables: Array<Identifier>,\n  name: string,\n  inputMap: BabelFileResult['map']\n): Array<string | null | undefined> {\n  const draftExpression = (fun.program.body.find((obj) =>\n    isFunctionDeclaration(obj)\n  ) ||\n    fun.program.body.find((obj) => isExpressionStatement(obj)) ||\n    undefined) as FunctionDeclaration | ExpressionStatement | undefined;\n\n  assertIsDefined(draftExpression);\n\n  const expression = isFunctionDeclaration(draftExpression)\n    ? draftExpression\n    : draftExpression.expression;\n\n  if (!('params' in expression && isBlockStatement(expression.body)))\n    throw new Error(\n      \"'expression' doesn't have property 'params' or 'expression.body' is not a BlockStatmenent!\\n'\"\n    );\n\n  const workletFunction = functionExpression(\n    identifier(name),\n    expression.params,\n    expression.body\n  );\n\n  const code = generate(workletFunction).code;\n\n  assertIsDefined(inputMap);\n\n  const includeSourceMap = shouldGenerateSourceMap();\n\n  if (includeSourceMap) {\n    // Clear contents array (should be empty anyways)\n    inputMap.sourcesContent = [];\n    // Include source contents in source map, because Flipper/iframe is not\n    // allowed to read files from disk.\n    for (const sourceFile of inputMap.sources) {\n      inputMap.sourcesContent.push(\n        fs.readFileSync(sourceFile).toString('utf-8')\n      );\n    }\n  }\n\n  const transformed = transformSync(code, {\n    plugins: [prependClosureVariablesIfNecessary(closureVariables)],\n    compact: !includeSourceMap,\n    sourceMaps: includeSourceMap,\n    inputSourceMap: inputMap,\n    ast: false,\n    babelrc: false,\n    configFile: false,\n    comments: false,\n  });\n\n  assertIsDefined(transformed);\n\n  let sourceMap;\n  if (includeSourceMap) {\n    sourceMap = convertSourceMap.fromObject(transformed.map).toObject();\n    // sourcesContent field contains a full source code of the file which contains the worklet\n    // and is not needed by the source map interpreter in order to symbolicate a stack trace.\n    // Therefore, we remove it to reduce the bandwith and avoid sending it potentially multiple times\n    // in files that contain multiple worklets. Along with sourcesContent.\n    delete sourceMap.sourcesContent;\n  }\n\n  return [transformed.code, JSON.stringify(sourceMap)];\n}\n\nexport { buildWorkletString };\n", "import { NodePath, transformSync, traverse } from '@babel/core';\nimport generate from '@babel/generator';\nimport {\n  ObjectMethod,\n  isObjectMethod,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  identifier,\n  Identifier,\n  objectProperty,\n  variableDeclaration,\n  variableDeclarator,\n  cloneNode,\n  isBlockStatement,\n  functionExpression,\n  objectExpression,\n  stringLiteral,\n  isFunctionDeclaration,\n  VariableDeclaration,\n  ExpressionStatement,\n  ReturnStatement,\n  isObjectProperty,\n  isMemberExpression,\n  isObjectExpression,\n  expressionStatement,\n  assignmentExpression,\n  memberExpression,\n  numericLiteral,\n  arrayExpression,\n  newExpression,\n  returnStatement,\n  blockStatement,\n  isFunctionExpression,\n  isIdentifier,\n  isProgram,\n  File as BabelFile,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './commonInterfaces';\nimport { hash, isRelease } from './commonFunctions';\nimport { globals } from './commonObjects';\nimport { assertIsDefined } from './asserts';\nimport { buildWorkletString } from './buildWorkletString';\nimport { relative } from 'path';\nimport { shouldGenerateSourceMap } from './commonFunctions';\n\nfunction makeWorkletName(\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >\n): string {\n  if (isObjectMethod(fun.node) && 'name' in fun.node.key) {\n    return fun.node.key.name;\n  }\n  if (isFunctionDeclaration(fun.node) && fun.node.id) {\n    return fun.node.id.name;\n  }\n  if (isFunctionExpression(fun.node) && isIdentifier(fun.node.id)) {\n    return fun.node.id.name;\n  }\n  return 'anonymous'; // fallback for ArrowFunctionExpression and unnamed FunctionExpression\n}\n\nfunction makeArrayFromCapturedBindings(\n  ast: BabelFile,\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >\n): Array<Identifier> {\n  const closure = new Map<string, Identifier>();\n  // this traverse looks for variables to capture\n  traverse(ast as BabelFile, {\n    Identifier(path) {\n      if (!path.isReferencedIdentifier()) return; // we only capture variables that were declared outside of the scope\n      const name = path.node.name;\n      if (globals.has(name)) return;\n      if (\n        'id' in fun.node &&\n        fun.node.id &&\n        'name' in fun.node.id &&\n        fun.node.id.name === name // we don't want to capture function's name in closure\n      ) {\n        return;\n      }\n\n      const parentNode = path.parent;\n\n      if (\n        isMemberExpression(parentNode) &&\n        parentNode.property === path.node &&\n        !parentNode.computed\n      ) {\n        return;\n      }\n\n      if (\n        isObjectProperty(parentNode) &&\n        isObjectExpression(path.parentPath.parent) &&\n        path.node !== parentNode.value\n      ) {\n        return;\n      }\n\n      let currentScope = path.scope;\n\n      while (currentScope != null) {\n        if (currentScope.bindings[name] != null) {\n          return; // this is for the case that we go too far?\n        }\n        currentScope = currentScope.parent;\n      }\n      closure.set(name, path.node);\n    },\n  });\n  return Array.from(closure.values());\n}\n\nfunction makeWorklet(\n  fun: NodePath<\n    | FunctionDeclaration\n    | FunctionExpression\n    | ObjectMethod\n    | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n): FunctionExpression {\n  // Returns a new FunctionExpression which is a workletized version of provided\n  // FunctionDeclaration, FunctionExpression, ArrowFunctionExpression or ObjectMethod.\n\n  const functionName = makeWorkletName(fun);\n\n  // remove 'worklet'; directive before generating string\n  fun.traverse({\n    DirectiveLiteral(path) {\n      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {\n        path.parentPath.remove();\n      }\n    },\n  });\n\n  // We use copy because some of the plugins don't update bindings and\n  // some even break them\n\n  assertIsDefined(state.file.opts.filename);\n  let codeObject = generate(fun.node, {\n    sourceMaps: true,\n    sourceFileName: state.file.opts.filename,\n  });\n\n  // We need to add a newline at the end, because there could potentially be a\n  // comment after the function that gets included here, and then the closing\n  // bracket would become part of the comment thus resulting in an error, since\n  // there is a missing closing bracket.\n  codeObject.code =\n    '(' + (isObjectMethod(fun) ? 'function ' : '') + codeObject.code + '\\n)';\n\n  const transformed = transformSync(codeObject.code, {\n    filename: state.file.opts.filename,\n    presets: ['@babel/preset-typescript'],\n    plugins: [\n      '@babel/plugin-transform-shorthand-properties',\n      '@babel/plugin-transform-arrow-functions',\n      '@babel/plugin-proposal-optional-chaining',\n      '@babel/plugin-proposal-nullish-coalescing-operator',\n      ['@babel/plugin-transform-template-literals', { loose: true }],\n    ],\n    ast: true,\n    babelrc: false,\n    configFile: false,\n    inputSourceMap: codeObject.map,\n  });\n\n  assertIsDefined(transformed);\n  assertIsDefined(transformed.ast);\n\n  const variables = makeArrayFromCapturedBindings(transformed.ast, fun);\n\n  const privateFunctionId = identifier('_f');\n  const clone = cloneNode(fun.node); // why clone here?\n  const funExpression = isBlockStatement(clone.body)\n    ? functionExpression(null, clone.params, clone.body)\n    : clone;\n\n  const [funString, sourceMapString] = buildWorkletString(\n    transformed.ast,\n    variables,\n    functionName,\n    transformed.map\n  );\n  assertIsDefined(funString);\n  const workletHash = hash(funString);\n\n  let location = state.file.opts.filename;\n  if (state.opts.relativeSourceLocation) {\n    location = relative(state.cwd, location);\n  }\n\n  let lineOffset = 1;\n  if (variables.length > 0) {\n    // When worklet captures some variables, we append closure destructing at\n    // the beginning of the function body. This effectively results in line\n    // numbers shifting by the number of captured variables (size of the\n    // closure) + 2 (for the opening and closing brackets of the destruct\n    // statement)\n    lineOffset -= variables.length + 2;\n  }\n\n  // more like path for worklet allocation\n  const pathForStringDefinitions = isProgram(fun.parentPath)\n    ? fun\n    : fun.findParent((path) => isProgram(path.parentPath));\n\n  assertIsDefined(pathForStringDefinitions);\n  assertIsDefined(pathForStringDefinitions.parentPath);\n\n  const initDataId =\n    pathForStringDefinitions.parentPath.scope.generateUidIdentifier(\n      // is it automatically added to the scope?\n      `worklet_${workletHash}_init_data`\n    );\n\n  const initDataObjectExpression = objectExpression([\n    objectProperty(identifier('code'), stringLiteral(funString)),\n    objectProperty(identifier('location'), stringLiteral(location)),\n    objectProperty(\n      identifier('sourceMap'),\n      shouldGenerateSourceMap()\n        ? stringLiteral(sourceMapString as string)\n        : identifier('undefined')\n    ),\n  ]);\n\n  // to add it before the actual JS function?\n  pathForStringDefinitions.insertBefore(\n    variableDeclaration('const', [\n      variableDeclarator(initDataId, initDataObjectExpression),\n    ])\n  );\n\n  if (isFunctionDeclaration(funExpression) || isObjectMethod(funExpression))\n    throw new Error(\n      \"'funExpression' is either FunctionDeclaration or ObjectMethod and cannot be used in variableDeclaration\\n\"\n    );\n\n  const statements: Array<\n    VariableDeclaration | ExpressionStatement | ReturnStatement\n  > = [\n    variableDeclaration('const', [\n      variableDeclarator(privateFunctionId, funExpression),\n    ]),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('_closure'), false),\n        objectExpression(\n          variables.map((variable) =>\n            objectProperty(identifier(variable.name), variable, false, true)\n          )\n        )\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('__initData'), false),\n        initDataId\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(privateFunctionId, identifier('__workletHash'), false),\n        numericLiteral(workletHash)\n      )\n    ),\n  ];\n\n  if (!isRelease()) {\n    statements.unshift(\n      variableDeclaration('const', [\n        variableDeclarator(\n          identifier('_e'),\n          arrayExpression([\n            newExpression(\n              memberExpression(identifier('global'), identifier('Error')),\n              []\n            ),\n            numericLiteral(lineOffset), // [kmagiera]\n            numericLiteral(-27), // the placement of opening bracket after Exception in line that defined '_e' variable\n          ])\n        ),\n      ])\n    );\n    statements.push(\n      expressionStatement(\n        assignmentExpression(\n          '=',\n          memberExpression(\n            privateFunctionId,\n            identifier('__stackDetails'),\n            false\n          ),\n          identifier('_e')\n        )\n      )\n    );\n  }\n\n  statements.push(returnStatement(privateFunctionId));\n\n  const newFun = functionExpression(undefined, [], blockStatement(statements));\n\n  return newFun;\n}\n\nexport { makeWorklet };\n", "import { NodePath } from '@babel/core';\nimport {\n  ObjectMethod,\n  identifier,\n  isIdentifier,\n  objectProperty,\n  callExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './commonInterfaces';\nimport { makeWorklet } from './makeWorklet';\n\nfunction processWorkletObjectMethod(\n  path: NodePath<ObjectMethod>,\n  state: ReanimatedPluginPass\n): void {\n  // Replaces ObjectMethod with a workletized version of itself.\n\n  const newFun = makeWorklet(path, state);\n\n  const replacement = objectProperty(\n    identifier(isIdentifier(path.node.key) ? path.node.key.name : ''),\n    callExpression(newFun, [])\n  );\n\n  path.replaceWith(replacement);\n}\n\nexport { processWorkletObjectMethod };\n", "import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  callExpression,\n  isScopable,\n  isExportNamedDeclaration,\n  isArrowFunctionExpression,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  variableDeclaration,\n  variableDeclarator,\n  Node as BabelNode,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './commonInterfaces';\nimport { makeWorklet } from './makeWorklet';\n\n// Replaces FunctionDeclaration, FunctionExpression or ArrowFunctionExpression\n// with a workletized version of itself.\n\nfunction processIfWorkletFunction(\n  path: NodePath<BabelNode> | Array<NodePath<BabelNode>>,\n  state: ReanimatedPluginPass\n): void {\n  if (\n    isFunctionDeclaration(path) ||\n    isFunctionExpression(path) ||\n    isArrowFunctionExpression(path)\n  )\n    processWorkletFunction(\n      path as NodePath<\n        FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n      >,\n      state\n    );\n}\n\nfunction processWorkletFunction(\n  path: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n): void {\n  const newFun = makeWorklet(path, state);\n\n  const replacement = callExpression(newFun, []);\n\n  // we check if function needs to be assigned to variable declaration.\n  // This is needed if function definition directly in a scope. Some other ways\n  // where function definition can be used is for example with variable declaration:\n  // const ggg = function foo() { }\n  // ^ in such a case we don't need to define variable for the function\n  const needDeclaration =\n    isScopable(path.parent) || isExportNamedDeclaration(path.parent);\n  path.replaceWith(\n    'id' in path.node && path.node.id && needDeclaration\n      ? variableDeclaration('const', [\n          variableDeclarator(path.node.id, replacement),\n        ])\n      : replacement\n  );\n}\n\nexport { processIfWorkletFunction };\n", "import { NodePath } from '@babel/core';\nimport {\n  CallExpression,\n  isSequenceExpression,\n  isObjectExpression,\n  ObjectMethod,\n  ObjectProperty,\n  isObjectMethod,\n  ObjectExpression,\n  isObjectProperty,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './commonInterfaces';\nimport { objectHooks, functionArgsToWorkletize } from './commonObjects';\nimport { processWorkletObjectMethod } from './processWorkletObjectMethod';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\n\nfunction processForCalleesWorklets(\n  path: NodePath<CallExpression>,\n  state: ReanimatedPluginPass\n): void {\n  const callee = isSequenceExpression(path.node.callee)\n    ? path.node.callee.expressions[path.node.callee.expressions.length - 1]\n    : path.node.callee;\n\n  let name;\n  if ('name' in callee) name = callee.name;\n  else if ('property' in callee && 'name' in callee.property)\n    name = callee.property.name;\n  else return;\n\n  if (objectHooks.has(name)) {\n    const workletToProcess = path.get('arguments.0') as NodePath<\n      CallExpression['arguments'][number]\n    >;\n    if (isObjectExpression(workletToProcess))\n      processObjectHookArgument(\n        workletToProcess as NodePath<ObjectExpression>,\n        state\n      );\n  } else processArguments(name, path, state);\n}\n\nfunction processObjectHookArgument(\n  path: NodePath<ObjectExpression>,\n  state: ReanimatedPluginPass\n): void {\n  const properties = path.get('properties') as Array<\n    NodePath<ObjectExpression['properties'][number]>\n  >;\n  for (const property of properties) {\n    if (isObjectMethod(property)) {\n      processWorkletObjectMethod(property as NodePath<ObjectMethod>, state);\n    } else if (isObjectProperty(property)) {\n      const value = property.get('value') as NodePath<ObjectProperty['value']>;\n      processIfWorkletFunction(value, state);\n    } else {\n      throw new Error(\n        '[Reanimated] Spread syntax (Babel SpreadElement type) as to-be workletized arguments is not supported for object hooks!\\n'\n      );\n    }\n  }\n}\n\nfunction processArguments(\n  name: string,\n  path: NodePath<CallExpression>,\n  state: ReanimatedPluginPass\n): void {\n  const indexes = functionArgsToWorkletize.get(name);\n  if (Array.isArray(indexes)) {\n    const argumentsArray = path.get('arguments') as Array<\n      NodePath<CallExpression['arguments'][number]>\n    >;\n    indexes.forEach((index) => {\n      const argumentToWorkletize = argumentsArray[index];\n      processIfWorkletFunction(argumentToWorkletize, state);\n    });\n  }\n}\n\nexport { processForCalleesWorklets };\n", "import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  isBlockStatement,\n  isDirectiveLiteral,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './commonInterfaces';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\n\nfunction processIfWorkletNode(\n  fun: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n): void {\n  fun.traverse({\n    DirectiveLiteral(path) {\n      const value = path.node.value;\n      if (\n        value === 'worklet' &&\n        path.getFunctionParent() === fun &&\n        isBlockStatement(fun.node.body)\n      ) {\n        // make sure \"worklet\" is listed among directives for the fun\n        // this is necessary as because of some bug, babel will attempt to\n        // process replaced function if it is nested inside another function\n        const directives = fun.node.body.directives;\n        if (\n          directives &&\n          directives.length > 0 &&\n          directives.some(\n            (directive) =>\n              isDirectiveLiteral(directive.value) &&\n              directive.value.value === 'worklet'\n          )\n        ) {\n          processIfWorkletFunction(fun, state);\n        }\n      }\n    },\n  });\n}\n\nexport { processIfWorkletNode };\n", "import { NodePath } from '@babel/core';\nimport {\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n  isIdentifier,\n  isCallExpression,\n  Expression,\n  isMemberExpression,\n  isExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './commonInterfaces';\nimport { processIfWorkletFunction } from './processIfWorkletFunction';\nimport {\n  gestureHandlerBuilderMethods,\n  gestureHandlerGestureObjects,\n} from './commonObjects';\n\nfunction isGestureObject(node: Expression): boolean {\n  // Checks if node matches `Gesture.Tap()` or similar.\n  /*\n  node: CallExpression(\n    callee: MemberExpression(\n      object: Identifier('Gesture')\n      property: Identifier('Tap')\n    )\n  )\n  */\n  return (\n    isCallExpression(node) &&\n    isMemberExpression(node.callee) &&\n    isIdentifier(node.callee.object) &&\n    node.callee.object.name === 'Gesture' &&\n    isIdentifier(node.callee.property) &&\n    gestureHandlerGestureObjects.has(node.callee.property.name)\n  );\n}\n\nfunction containsGestureObject(node: Expression): boolean {\n  // Checks if node matches the pattern `Gesture.Foo()[*]`\n  // where `[*]` represents any number of chained method calls, like `.something(42)`.\n\n  // direct call\n  if (isGestureObject(node)) {\n    return true;\n  }\n\n  // method chaining\n  if (\n    isCallExpression(node) &&\n    isMemberExpression(node.callee) &&\n    containsGestureObject(node.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isGestureObjectEventCallbackMethod(node: Expression): boolean {\n  // Checks if node matches the pattern `Gesture.Foo()[*].onBar`\n  // where `[*]` represents any number of method calls.\n  return (\n    isMemberExpression(node) &&\n    isIdentifier(node.property) &&\n    gestureHandlerBuilderMethods.has(node.property.name) &&\n    containsGestureObject(node.object)\n  );\n}\n\nfunction processIfGestureHandlerEventCallbackFunctionNode(\n  path: NodePath<\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n  >,\n  state: ReanimatedPluginPass\n): void {\n  // Auto-workletizes React Native Gesture Handler callback functions.\n  // Detects `Gesture.Tap().onEnd(<fun>)` or similar, but skips `something.onEnd(<fun>)`.\n  // Supports method chaining as well, e.g. `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`.\n\n  // Example #1: `Gesture.Tap().onEnd(<fun>)`\n  /*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: Identifier('Gesture')\n          property: Identifier('Tap')\n        )\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun]\n  )\n  */\n\n  // Example #2: `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`\n  /*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: CallExpression(\n            callee: MemberExpression(\n              object: CallExpression(\n                callee: MemberExpression(\n                  object: Identifier('Gesture')\n                  property: Identifier('Tap')\n                )\n              )\n              property: Identifier('onStart')\n            )\n            arguments: [fun1]\n          )\n          property: Identifier('onUpdate')\n        )\n        arguments: [fun2]\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun3]\n  )\n  */\n\n  if (\n    isCallExpression(path.parent) &&\n    isExpression(path.parent.callee) &&\n    isGestureObjectEventCallbackMethod(path.parent.callee)\n  ) {\n    processIfWorkletFunction(path, state);\n  }\n}\n\nexport { processIfGestureHandlerEventCallbackFunctionNode };\n", "import { NodePath } from '@babel/core';\nimport {\n  MemberExpression,\n  callExpression,\n  arrowFunctionExpression,\n  isMemberExpression,\n  isArrayExpression,\n  isObjectExpression,\n  ArrayExpression,\n  ObjectExpression,\n  isObjectProperty,\n  JSXAttribute,\n  isJSXExpressionContainer,\n  Expression,\n  identifier,\n  stringLiteral,\n  expressionStatement,\n  memberExpression,\n  returnStatement,\n  blockStatement,\n  ObjectProperty,\n  isIdentifier,\n  CallExpression,\n} from '@babel/types';\nimport { isRelease } from './commonFunctions';\nimport { ReanimatedPluginPass } from './commonInterfaces';\n\nfunction generateInlineStylesWarning(\n  path: NodePath<MemberExpression>\n): CallExpression {\n  // replaces `sharedvalue.value` with `(()=>{console.warn(require('react-native-reanimated').getUseOfValueInStyleWarning());return sharedvalue.value;})()`\n  return callExpression(\n    arrowFunctionExpression(\n      [],\n      blockStatement([\n        expressionStatement(\n          callExpression(\n            memberExpression(identifier('console'), identifier('warn')),\n            [\n              callExpression(\n                memberExpression(\n                  callExpression(identifier('require'), [\n                    stringLiteral('react-native-reanimated'),\n                  ]),\n                  identifier('getUseOfValueInStyleWarning')\n                ),\n                []\n              ),\n            ]\n          )\n        ),\n        returnStatement(path.node),\n      ])\n    ),\n    []\n  );\n}\n\nfunction processPropertyValueForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n): void {\n  // if it's something like object.value then raise a warning\n  if (isMemberExpression(path.node) && isIdentifier(path.node.property)) {\n    if (path.node.property.name === 'value') {\n      path.replaceWith(\n        generateInlineStylesWarning(path as NodePath<MemberExpression>)\n      );\n    }\n  }\n}\n\nfunction processTransformPropertyForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n): void {\n  if (isArrayExpression(path.node)) {\n    const elements = path.get('elements') as Array<\n      NodePath<ArrayExpression['elements'][number]>\n    >;\n    for (const element of elements) {\n      if (isObjectExpression(element.node)) {\n        processStyleObjectForInlineStylesWarning(\n          element as NodePath<ObjectExpression>\n        );\n      }\n    }\n  }\n}\n\nfunction processStyleObjectForInlineStylesWarning(\n  path: NodePath<ObjectExpression>\n): void {\n  const properties = path.get('properties') as Array<\n    NodePath<ObjectExpression['properties'][number]>\n  >;\n  for (const property of properties) {\n    if (!isObjectProperty(property.node)) continue;\n    const value = property.get('value') as NodePath<ObjectProperty['value']>;\n    if (isObjectProperty(property)) {\n      if (\n        isIdentifier(property.node.key) &&\n        property.node.key.name === 'transform'\n      ) {\n        processTransformPropertyForInlineStylesWarning(value);\n      } else {\n        processPropertyValueForInlineStylesWarning(value);\n      }\n    }\n  }\n}\n\nfunction processInlineStylesWarning(\n  path: NodePath<JSXAttribute>,\n  state: ReanimatedPluginPass\n): void {\n  if (isRelease()) return;\n  if (state.opts.disableInlineStylesWarning) return;\n  if (path.node.name.name !== 'style') return;\n  if (!isJSXExpressionContainer(path.node.value)) return;\n\n  const expression = path\n    .get('value')\n    .get('expression') as NodePath<Expression>;\n  // style={[{...}, {...}]}\n  if (isArrayExpression(expression.node)) {\n    const elements = expression.get('elements') as Array<\n      NodePath<ArrayExpression['elements'][number]>\n    >;\n    for (const element of elements) {\n      if (isObjectExpression(element.node)) {\n        processStyleObjectForInlineStylesWarning(\n          element as NodePath<ObjectExpression>\n        );\n      }\n    }\n  }\n  // style={{...}}\n  else if (isObjectExpression(expression.node)) {\n    processStyleObjectForInlineStylesWarning(\n      expression as NodePath<ObjectExpression>\n    );\n  }\n}\n\nexport { processInlineStylesWarning };\n", "import { PluginItem, NodePath } from '@babel/core';\nimport { globals } from './commonObjects';\nimport {\n  CallExpression,\n  FunctionDeclaration,\n  FunctionExpression,\n  ArrowFunctionExpression,\n} from '@babel/types';\nimport { ReanimatedPluginPass } from './commonInterfaces';\nimport { processForCalleesWorklets } from './processForCalleesWorklets';\nimport { processIfWorkletNode } from './processIfWorkletNode';\nimport { processIfGestureHandlerEventCallbackFunctionNode } from './processIfGestureHandlerEventCallbackFunctionNode';\nimport { processInlineStylesWarning } from './processInlineStylesWarning';\n\nmodule.exports = function (): PluginItem {\n  return {\n    pre() {\n      // allows adding custom globals such as host-functions\n      if (this.opts != null && Array.isArray(this.opts.globals)) {\n        this.opts.globals.forEach((name: string) => {\n          globals.add(name);\n        });\n      }\n    },\n    visitor: {\n      CallExpression: {\n        enter(path: NodePath<CallExpression>, state: ReanimatedPluginPass) {\n          processForCalleesWorklets(path, state);\n        },\n      },\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression': {\n        enter(\n          path: NodePath<\n            FunctionDeclaration | FunctionExpression | ArrowFunctionExpression\n          >,\n          state: ReanimatedPluginPass\n        ) {\n          processIfWorkletNode(path, state);\n          processIfGestureHandlerEventCallbackFunctionNode(path, state);\n        },\n      },\n      JSXAttribute: {\n        enter(path, state) {\n          processInlineStylesWarning(path, state);\n        },\n      },\n    },\n  };\n};\n"],
  "mappings": "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",
  "names": ["generate", "generate", "import_core", "import_generator", "import_types", "import_types", "import_types", "import_types", "import_types", "import_types", "import_types"]
}
